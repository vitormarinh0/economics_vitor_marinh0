---
title: "Rede de Colabora√ß√£o Cient√≠fica de Institui√ß√µes Cubanas"
description: "Mapeamento da coprodu√ß√£o de artigos entre o grupo BioCubaFarma, o CECMED e institui√ß√µes internacionais"
date: 2025-08-06
categories: [coopera√ß√£o internacional, bibliometria, ci√™ncia e tecnologia, Cuba]
image: BD88B4E4-5A24-4019-936D-873D03B03435.png
format:
  html:
    page-layout: full
    toc: true
    toc-depth: 2
    code-fold: true
    code-summary: "Exibir c√≥digo"
---

## Colabora√ß√£o cient√≠fica como estrat√©gia de soberania tecnol√≥gica

O gr√°fico abaixo representa a **rede de colabora√ß√£o institucional** entre autores vinculados ao grupo **BioCubaFarma**, ao **CECMED** (√≥rg√£o regulador cubano), e seus parceiros internacionais, com base em 219 artigos publicados entre 1997 e 2024.

Post: <https://www.ipea.gov.br/cts/pt/central-de-conteudo/artigos/artigos/486-colaboracao-cientifica-o-caso-de-empresas-farmaceuticas-e-de-biotecnologia-cubanas?highlight=WyJ0dWxpbyJd> 

![](rede_colab.png)

------------------------------------------------------------------------

## Metodologia

A rede foi constru√≠da a partir de dados extra√≠dos das bases **Web of Science** e **Scopus**, utilizando:

-   Extra√ß√£o de coautorias por institui√ß√£o
-   Agrupamento por par de institui√ß√µes com contagem de frequ√™ncia
-   Gera√ß√£o de um grafo n√£o direcionado (`networkx`)
-   Detec√ß√£o de comunidades modulares (`greedy_modularity_communities`)
-   Tamanhos dos n√≥s e arestas ajustados conforme grau de colabora√ß√£o

------------------------------------------------------------------------

## Destaques da rede

-   A rede √© **altamente concentrada em institui√ß√µes cubanas**, com **BioCubaFarma**, **CIM**, **CIDEM**, **CIGB** e **CECMED** no n√∫cleo.
-   A **Universidade de Havana**, o **Instituto de Inmunolog√≠a Molecular (CIM)** e o **Finlay (IFV)** aparecem como hubs centrais da ci√™ncia biom√©dica cubana.
-   Institui√ß√µes da **China**, **Espanha**, **Brasil** e **Estados Unidos** formam n√∫cleos perif√©ricos, conectados por publica√ß√µes coassinadas.

------------------------------------------------------------------------

## Parcerias internacionais

Segundo a an√°lise:

-   **China**: colabora√ß√£o intensa com universidades (Sichuan, Shanghai, Nanjing) e empresas (Olisynn Biotech, PRIMA Drug), com foco em vacinas e biotecnologia.
-   **Brasil**: 45 autores em 16 artigos, com destaque para a **UFRGS**, **UFBA**, **UFSC**, **ANVISA** e o **Hospital Albert Einstein**, atuando majoritariamente com o **CIDEM**.
-   **Estados Unidos**: coautorias com universidades como **Arizona**, **Pittsburgh**, e o **Hospital de Cincinnati**, apesar do embargo.

------------------------------------------------------------------------

## C√≥digo base (Python)

```{r, eval=FALSE}
#!pip install openpyxl # install the module for reading excel files
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import re
from adjustText import adjust_text  # Biblioteca para evitar sobreposi√ß√£o de textos
from networkx.algorithms import community  # Para detectar clusters

# üîπ 1. Carregar o DataFrame (substitua pelo nome do seu arquivo)
df = pd.read_excel("/content/drive/MyDrive/bibliometria_cuba/Cuba_Autores_Inst_20.xlsx")  # Substitua pelo seu arquivo

# üîπ 2. Filtrar apenas as colunas de institui√ß√µes
instituicao_cols = [col for col in df.columns if "Instituicao" in col]

# üîπ 3. Criar uma lista com todas as institui√ß√µes por artigo
instituicoes_lista = df[instituicao_cols].values.tolist()

# üîπ 4. Criar a matriz de colabora√ß√£o entre institui√ß√µes
coocorrencia = {}

for instituicoes in instituicoes_lista:
    unicas = list(set(filter(pd.notna, instituicoes)))  # Remover NaN e duplicatas
    for i in range(len(unicas)):
        for j in range(i + 1, len(unicas)):
            par = tuple(sorted([unicas[i], unicas[j]]))
            coocorrencia[par] = coocorrencia.get(par, 0) + 1

# üîπ 5. Criar o grafo de colabora√ß√£o entre institui√ß√µes
G = nx.Graph()

# Adicionar arestas com pesos
for (inst1, inst2), peso in coocorrencia.items():
    G.add_edge(inst1, inst2, weight=peso)

# üîπ 6. Detectar clusters (comunidades) na rede
clusters = community.greedy_modularity_communities(G)  # M√©todo de detec√ß√£o de comunidades

# üîπ 7. Fun√ß√£o para extrair sigla entre par√™nteses ou aplicar quebra de linha
def extrair_sigla_ou_quebrar(texto, max_chars=30):
    """Se houver sigla entre par√™nteses, retorna a sigla. Caso contr√°rio, quebra o texto."""
    match = re.search(r"\((.*?)\)", texto)
    if match:
        return match.group(1)  # Retornar apenas a sigla
    else:
        palavras = texto.split()
        linhas = []
        linha_atual = ""

        for palavra in palavras:
            if len(linha_atual) + len(palavra) + 1 > max_chars:
                linhas.append(linha_atual)
                linha_atual = palavra
            else:
                linha_atual += " " + palavra if linha_atual else palavra

        if linha_atual:
            linhas.append(linha_atual)

        return "\n".join(linhas)

# üîπ 8. Criar um novo gr√°fico de rede com melhorias
plt.figure(figsize=(14, 10))

# Ajustar tamanho dos n√≥s com base no grau de colabora√ß√£o
node_size = [G.degree(n) * 30 for n in G.nodes()]

# Ajustar espessura das arestas com base no peso da colabora√ß√£o
edge_width = [G[u][v]['weight'] * 0.2 for u, v in G.edges()]

# Definir nova posi√ß√£o dos n√≥s para melhor distribui√ß√£o
pos = nx.spring_layout(G, k=0.30, seed=30)

# üîπ 9. Melhorias na visualiza√ß√£o
nx.draw_networkx_edges(G, pos, alpha=0.2, width=edge_width, edge_color="#bb672d")
nx.draw_networkx_nodes(G, pos, node_size=node_size, alpha=0.65, node_color="#bdcc23")

# üîπ 10. Selecionar n√≥s para exibir r√≥tulos
top_n_labels = 20  # Exibir as 25 institui√ß√µes mais conectadas

# Adicionar 3 institui√ß√µes de cada cluster para representatividade
labels = {}
top_nodes = sorted(G.degree, key=lambda x: x[1], reverse=True)[:top_n_labels]

# Adicionar os 25 n√≥s mais conectados
for node, _ in top_nodes:
    labels[node] = extrair_sigla_ou_quebrar(node)

# Adicionar representantes dos clusters menores
for c in clusters:
    cluster_nodes = sorted(c, key=lambda x: G.degree(x), reverse=True)[:2]  # 3 principais de cada cluster
    for node in cluster_nodes:
        if node not in labels:  # Evitar duplica√ß√£o de r√≥tulos
            labels[node] = extrair_sigla_ou_quebrar(node)

# Criar r√≥tulos como textos individuais (para ajuste autom√°tico)
texts = []
for node, text in labels.items():
    x, y = pos[node]
    texts.append(plt.text(x, y, text, fontsize=9, ha="center", va="center", color="black"))

# üîπ 11. Ajustar automaticamente os r√≥tulos para evitar sobreposi√ß√£o
adjust_text(texts, arrowprops=dict(arrowstyle="-", color="gray", lw=0.3))

# üîπ 12. Exibi√ß√£o final
plt.title("Rede de Colabora√ß√£o \nInstitucional", fontsize=14)
plt.savefig("/content/drive/MyDrive/bibliometria_cuba/rede_colab.png", dpi=300, bbox_inches="tight")
plt.show()

```
