{
  "hash": "5aa66d10f5af193dff3868248bac2887",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Rede de Colabora√ß√£o Cient√≠fica de Institui√ß√µes Cubanas\"\ndescription: \"Mapeamento da coprodu√ß√£o de artigos entre o grupo BioCubaFarma, o CECMED e institui√ß√µes internacionais\"\ndate: 2025-08-06\ncategories: [coopera√ß√£o internacional, bibliometria, ci√™ncia e tecnologia, Cuba]\nimage: BD88B4E4-5A24-4019-936D-873D03B03435.png\nformat:\n  html:\n    page-layout: full\n    toc: true\n    toc-depth: 2\n    code-fold: true\n    code-summary: \"Exibir c√≥digo\"\n---\n\n## Colabora√ß√£o cient√≠fica como estrat√©gia de soberania tecnol√≥gica\n\nO gr√°fico abaixo representa a **rede de colabora√ß√£o institucional** entre autores vinculados ao grupo **BioCubaFarma**, ao **CECMED** (√≥rg√£o regulador cubano), e seus parceiros internacionais, com base em 219 artigos publicados entre 1997 e 2024.\n\nPost: <https://www.ipea.gov.br/cts/pt/central-de-conteudo/artigos/artigos/486-colaboracao-cientifica-o-caso-de-empresas-farmaceuticas-e-de-biotecnologia-cubanas?highlight=WyJ0dWxpbyJd> \n\n![](rede_colab.png)\n\n------------------------------------------------------------------------\n\n## Metodologia\n\nA rede foi constru√≠da a partir de dados extra√≠dos das bases **Web of Science** e **Scopus**, utilizando:\n\n-   Extra√ß√£o de coautorias por institui√ß√£o\n-   Agrupamento por par de institui√ß√µes com contagem de frequ√™ncia\n-   Gera√ß√£o de um grafo n√£o direcionado (`networkx`)\n-   Detec√ß√£o de comunidades modulares (`greedy_modularity_communities`)\n-   Tamanhos dos n√≥s e arestas ajustados conforme grau de colabora√ß√£o\n\n------------------------------------------------------------------------\n\n## Destaques da rede\n\n-   A rede √© **altamente concentrada em institui√ß√µes cubanas**, com **BioCubaFarma**, **CIM**, **CIDEM**, **CIGB** e **CECMED** no n√∫cleo.\n-   A **Universidade de Havana**, o **Instituto de Inmunolog√≠a Molecular (CIM)** e o **Finlay (IFV)** aparecem como hubs centrais da ci√™ncia biom√©dica cubana.\n-   Institui√ß√µes da **China**, **Espanha**, **Brasil** e **Estados Unidos** formam n√∫cleos perif√©ricos, conectados por publica√ß√µes coassinadas.\n\n------------------------------------------------------------------------\n\n## Parcerias internacionais\n\nSegundo a an√°lise:\n\n-   **China**: colabora√ß√£o intensa com universidades (Sichuan, Shanghai, Nanjing) e empresas (Olisynn Biotech, PRIMA Drug), com foco em vacinas e biotecnologia.\n-   **Brasil**: 45 autores em 16 artigos, com destaque para a **UFRGS**, **UFBA**, **UFSC**, **ANVISA** e o **Hospital Albert Einstein**, atuando majoritariamente com o **CIDEM**.\n-   **Estados Unidos**: coautorias com universidades como **Arizona**, **Pittsburgh**, e o **Hospital de Cincinnati**, apesar do embargo.\n\n------------------------------------------------------------------------\n\n## C√≥digo base (Python)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#!pip install openpyxl # install the module for reading excel files\nimport pandas as pd\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport re\nfrom adjustText import adjust_text  # Biblioteca para evitar sobreposi√ß√£o de textos\nfrom networkx.algorithms import community  # Para detectar clusters\n\n# üîπ 1. Carregar o DataFrame (substitua pelo nome do seu arquivo)\ndf = pd.read_excel(\"/content/drive/MyDrive/bibliometria_cuba/Cuba_Autores_Inst_20.xlsx\")  # Substitua pelo seu arquivo\n\n# üîπ 2. Filtrar apenas as colunas de institui√ß√µes\ninstituicao_cols = [col for col in df.columns if \"Instituicao\" in col]\n\n# üîπ 3. Criar uma lista com todas as institui√ß√µes por artigo\ninstituicoes_lista = df[instituicao_cols].values.tolist()\n\n# üîπ 4. Criar a matriz de colabora√ß√£o entre institui√ß√µes\ncoocorrencia = {}\n\nfor instituicoes in instituicoes_lista:\n    unicas = list(set(filter(pd.notna, instituicoes)))  # Remover NaN e duplicatas\n    for i in range(len(unicas)):\n        for j in range(i + 1, len(unicas)):\n            par = tuple(sorted([unicas[i], unicas[j]]))\n            coocorrencia[par] = coocorrencia.get(par, 0) + 1\n\n# üîπ 5. Criar o grafo de colabora√ß√£o entre institui√ß√µes\nG = nx.Graph()\n\n# Adicionar arestas com pesos\nfor (inst1, inst2), peso in coocorrencia.items():\n    G.add_edge(inst1, inst2, weight=peso)\n\n# üîπ 6. Detectar clusters (comunidades) na rede\nclusters = community.greedy_modularity_communities(G)  # M√©todo de detec√ß√£o de comunidades\n\n# üîπ 7. Fun√ß√£o para extrair sigla entre par√™nteses ou aplicar quebra de linha\ndef extrair_sigla_ou_quebrar(texto, max_chars=30):\n    \"\"\"Se houver sigla entre par√™nteses, retorna a sigla. Caso contr√°rio, quebra o texto.\"\"\"\n    match = re.search(r\"\\((.*?)\\)\", texto)\n    if match:\n        return match.group(1)  # Retornar apenas a sigla\n    else:\n        palavras = texto.split()\n        linhas = []\n        linha_atual = \"\"\n\n        for palavra in palavras:\n            if len(linha_atual) + len(palavra) + 1 > max_chars:\n                linhas.append(linha_atual)\n                linha_atual = palavra\n            else:\n                linha_atual += \" \" + palavra if linha_atual else palavra\n\n        if linha_atual:\n            linhas.append(linha_atual)\n\n        return \"\\n\".join(linhas)\n\n# üîπ 8. Criar um novo gr√°fico de rede com melhorias\nplt.figure(figsize=(14, 10))\n\n# Ajustar tamanho dos n√≥s com base no grau de colabora√ß√£o\nnode_size = [G.degree(n) * 30 for n in G.nodes()]\n\n# Ajustar espessura das arestas com base no peso da colabora√ß√£o\nedge_width = [G[u][v]['weight'] * 0.2 for u, v in G.edges()]\n\n# Definir nova posi√ß√£o dos n√≥s para melhor distribui√ß√£o\npos = nx.spring_layout(G, k=0.30, seed=30)\n\n# üîπ 9. Melhorias na visualiza√ß√£o\nnx.draw_networkx_edges(G, pos, alpha=0.2, width=edge_width, edge_color=\"#bb672d\")\nnx.draw_networkx_nodes(G, pos, node_size=node_size, alpha=0.65, node_color=\"#bdcc23\")\n\n# üîπ 10. Selecionar n√≥s para exibir r√≥tulos\ntop_n_labels = 20  # Exibir as 25 institui√ß√µes mais conectadas\n\n# Adicionar 3 institui√ß√µes de cada cluster para representatividade\nlabels = {}\ntop_nodes = sorted(G.degree, key=lambda x: x[1], reverse=True)[:top_n_labels]\n\n# Adicionar os 25 n√≥s mais conectados\nfor node, _ in top_nodes:\n    labels[node] = extrair_sigla_ou_quebrar(node)\n\n# Adicionar representantes dos clusters menores\nfor c in clusters:\n    cluster_nodes = sorted(c, key=lambda x: G.degree(x), reverse=True)[:2]  # 3 principais de cada cluster\n    for node in cluster_nodes:\n        if node not in labels:  # Evitar duplica√ß√£o de r√≥tulos\n            labels[node] = extrair_sigla_ou_quebrar(node)\n\n# Criar r√≥tulos como textos individuais (para ajuste autom√°tico)\ntexts = []\nfor node, text in labels.items():\n    x, y = pos[node]\n    texts.append(plt.text(x, y, text, fontsize=9, ha=\"center\", va=\"center\", color=\"black\"))\n\n# üîπ 11. Ajustar automaticamente os r√≥tulos para evitar sobreposi√ß√£o\nadjust_text(texts, arrowprops=dict(arrowstyle=\"-\", color=\"gray\", lw=0.3))\n\n# üîπ 12. Exibi√ß√£o final\nplt.title(\"Rede de Colabora√ß√£o \\nInstitucional\", fontsize=14)\nplt.savefig(\"/content/drive/MyDrive/bibliometria_cuba/rede_colab.png\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}